<html>
<!-- Mirrored from archives.miloush.net/michkap/archive/2005/05/21/420708.html by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 25 May 2017 00:42:41 GMT -->
<head><meta charset="utf-8" /><meta name="viewport" content="width=device-width" /><title>Getting exactly ONE Unicode code point out of UTF-8</title></head><body>
<h1>Getting exactly ONE Unicode code point out of UTF-8</h1>
<p><em>by Michael S. Kaplan, published on 2005/05/21 05:45 -04:00, original URI: http://blogs.msdn.com/b/michkap/archive/2005/05/21/420708.aspx</em></p>
<hr/> <!-- Archival Source: ProcessPostNew -->
<P><FONT face=Tahoma>Now this is a question that I would make into an interview question, if only there were some way to do all the setup work in time.</FONT></P>
<P><FONT face=Tahoma>Unfortunately, unless the candidate is very knowledgable about internationalization on the way in, there is no way to get them all of the information to solve the problem in such a short time. </FONT></P>
<P><FONT face=Tahoma>I figure that if it can't make a good interview question, it might at least make a good blog post! :-)</FONT></P>
<P><FONT face=Tahoma>Anyway, the question is simple -- how can you get a single UTF-8 code point out of a stream of UTF-8 data?</FONT></P>
<P><FONT face=Tahoma>There are many times you may want to do this -- like if you are looking for a <a href="http://archives.miloush.net/michkap/archive/2005/01/20/357028.html">UTF-8 BOM</A>. But the real question is how can you do it....</FONT></P>
<P><FONT face=Tahoma><EM>(If you are going to test yourself then read no further and try to work out a solution, then come back to look at the rest of the post!)</EM></FONT></P>
<P><FONT face=Tahoma>Now legal (valid) UTF-8 will be between one and four bytes per code point. Thus if converting four bytes of UTF-8 to UTF-16, you could end up with between one and four UTF-16 code points. Using the distribution I pointed out yesterday:</FONT></P><FONT face=Tahoma>
<UL>
<LI><FONT face="Courier New"><STRONG>&nbsp;<A href="http://www.fileformat.info/info/unicode/char/0000/index.htm">U+0000</A> -&nbsp;&nbsp; <A href="http://www.fileformat.info/info/unicode/char/007f/index.htm">U+007f</A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1 byte</STRONG></FONT> 
<LI><FONT face="Courier New"><STRONG>&nbsp;<A href="http://www.fileformat.info/info/unicode/char/0080/index.htm">U+0080</A> -&nbsp;&nbsp; <A href="http://www.fileformat.info/info/unicode/char/07ff/index.htm">U+07ff</A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2 bytes</STRONG></FONT> 
<LI><STRONG><FONT face="Courier New">&nbsp;<A href="http://www.fileformat.info/info/unicode/char/0800/index.htm">U+0800</A> -&nbsp;&nbsp; <A href="http://www.fileformat.info/info/unicode/char/ffff/index.htm">U+ffff</A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3 bytes</FONT></STRONG> 
<LI><STRONG><FONT face="Courier New"><A href="http://www.fileformat.info/info/unicode/char/10000/index.htm">U+10000</A> - <A href="http://www.fileformat.info/info/unicode/char/10ffff/index.htm">U+10ffff</A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4 bytes</FONT></STRONG></LI></UL></FONT>
<P><FONT face=Tahoma>now right away this may point out one method you can use -- just take four bytes and convert them into a four-WCHAR scratchpad with the <A href="http://msdn.microsoft.com/library/en-us/intl/unicode_17si.asp">MultiByteToWideChar</A> function. Then ignore it all except for the first WCHAR, like this:</FONT></P>
<BLOCKQUOTE dir=ltr>
<P><FONT face="Courier New"><STRONG>WCHAR Scratch[4] = {0};<BR>int cch = </STRONG></FONT><FONT face="Courier New"><STRONG>MultiByteToWideChar(CP_UTF8, 0, lpsz, 4, Scratch, sizeof(Scratch) / sizeof(WCHAR));<BR><BR>if(cch &gt; 0) {<BR>&nbsp;&nbsp;&nbsp; <FONT color=#008000>// Use Scratch[0] to do whatever you wanted to do here</FONT><BR>}</STRONG></FONT></P></BLOCKQUOTE>
<P><FONT face=Tahoma>Now if this were an interview I'd expect that the candidate (who would have impressed me if she thought of this answer) would take care of the obvious issues like making sure that the UTF-8 buffer represented by <EM>lpsz</EM> was at least four bytes in size. </FONT></P>
<P><FONT face=Tahoma>And I would then point out that a call to <A href="http://msdn.microsoft.com/library/en-us/winui/winui/windowsuserinterface/resources/strings/stringreference/stringfunctions/lstrlen.asp">lstrlenA</A> is not&nbsp;the best answer since that would walk the whole string when you only needed to walk at most four bytes of it. The easiest solution then would be to just write a mini lstrlenN-esque function or just walk a few bytes right there. </FONT></P>
<P><FONT face=Tahoma>And then (if this were an interview) I would ask him to perhaps build this approach into a function that would handle the generic case of a function whose job is to "nibble" that first code point out.</FONT></P>
<P><FONT face=Tahoma>But first I would ask her about how she would conditionally increment the pointer past that one character. </FONT></P>
<P><FONT face=Tahoma>Hmmm.... almost a brain teaser!</FONT></P>
<P><FONT face=Tahoma>That <EM>cch</EM> value will be somewhere from 1 to 4, which gives some hints:</FONT></P>
<UL>
<LI><FONT face=Tahoma>If it is 4, you only have to increment by 1 byte;</FONT> 
<LI><FONT face=Tahoma>If it is 1, you have to increment by 4 bytes;</FONT> 
<LI><FONT face=Tahoma>If it is 2, you have to increment by 1, 2, or 3 bytes (and then the other code point would be 3, 2, or 1 bytes, respectively);</FONT> 
<LI><FONT face=Tahoma>If it is 3, you have to increment by 1 or 2 bytes (and then the other two code points would also be 1 or 2 bytes each).</FONT></LI></UL>
<P><FONT face=Tahoma>There might be an attempt at a blind alley as he tries to figure out how to determine how to determine the answer with one or two more calls to MultiByteToWideChar. I'd quickly hint him away from that idea, and </FONT><FONT face=Tahoma>point him back at that range table:</FONT></P><FONT face=Tahoma>
<LI><FONT face="Courier New"><STRONG>&nbsp;<A href="http://www.fileformat.info/info/unicode/char/0000/index.htm">U+0000</A> -&nbsp;&nbsp; <A href="http://www.fileformat.info/info/unicode/char/007f/index.htm">U+007f</A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1 byte</STRONG></FONT> 
<LI><FONT face="Courier New"><STRONG>&nbsp;<A href="http://www.fileformat.info/info/unicode/char/0080/index.htm">U+0080</A> -&nbsp;&nbsp; <A href="http://www.fileformat.info/info/unicode/char/07ff/index.htm">U+07ff</A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2 bytes</STRONG></FONT> 
<LI><STRONG><FONT face="Courier New">&nbsp;<A href="http://www.fileformat.info/info/unicode/char/0800/index.htm">U+0800</A> -&nbsp;&nbsp; <A href="http://www.fileformat.info/info/unicode/char/ffff/index.htm">U+ffff</A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3 bytes</FONT></STRONG> 
<LI><STRONG><FONT face="Courier New"><A href="http://www.fileformat.info/info/unicode/char/10000/index.htm">U+10000</A> - <A href="http://www.fileformat.info/info/unicode/char/10ffff/index.htm">U+10ffff</A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4 bytes (U+d800 U+dc00&nbsp;- U+dbff U+dfff)</FONT></STRONG></FONT> 
<P><FONT face=Tahoma>The candidate could then look at this table and figure out the easiest code method to figure out the answer based on it and that one code point.</FONT></P>
<P><FONT face=Tahoma>Or, if she was going to really impress me and she asked (or even better if she already knew!) the way that the UTF-8 bits are laid out:</FONT></P>
<P>
<TABLE cellSpacing=1 cellPadding=1 align=center>

<TR>
<TD><FONT face="Courier New" size=2>UTF-16</FONT></TD>
<TD><FONT face="Courier New" size=2>1st Byte</FONT></TD>
<TD><FONT face="Courier New" size=2>2nd Byte</FONT></TD>
<TD><FONT face="Courier New" size=2>3rd Byte</FONT></TD>
<TD><FONT face="Courier New" size=2>4th Byte</FONT></TD></TR>
<TR>
<TD><FONT face="Courier New" size=2>00000000 0xxxxxxx&nbsp;&nbsp;&nbsp; </FONT></TD>
<TD><FONT face="Courier New" size=2>0xxxxxxx&nbsp;&nbsp;&nbsp; </FONT></TD>
<TD><FONT face="Courier New" size=2>-</FONT></TD>
<TD><FONT face="Courier New" size=2>-</FONT></TD>
<TD><FONT face="Courier New" size=2>-</FONT></TD></TR>
<TR>
<TD><FONT face="Courier New" size=2>00000yyy&nbsp;yyxxxxxx&nbsp;&nbsp;&nbsp; </FONT></TD>
<TD><FONT face="Courier New" size=2>110yyyyy&nbsp;&nbsp;&nbsp; </FONT></TD>
<TD><FONT face="Courier New" size=2>10xxxxxx&nbsp;&nbsp;&nbsp; </FONT></TD>
<TD><FONT face="Courier New" size=2>-</FONT></TD>
<TD><FONT face="Courier New" size=2>-</FONT></TD></TR>
<TR>
<TD><FONT face="Courier New" size=2>zzzzyyyy yyxxxxxx&nbsp;&nbsp;&nbsp; </FONT></TD>
<TD><FONT face="Courier New" size=2>1110zzzz&nbsp;&nbsp;&nbsp; </FONT></TD>
<TD><FONT face="Courier New" size=2>10yyyyyy&nbsp;&nbsp;&nbsp; </FONT></TD>
<TD><FONT face="Courier New" size=2>10xxxxxx&nbsp;&nbsp;&nbsp; </FONT></TD>
<TD><FONT face="Courier New" size=2>-</FONT></TD></TR>
<TR>
<TD><FONT face="Courier New" size=2>110110ww wwzzzzyy&nbsp;&nbsp;&nbsp; <BR>110111yy yyxxxxxx&nbsp;&nbsp;&nbsp; </FONT></TD>
<TD><FONT face="Courier New" size=2>11110uuu&nbsp;&nbsp;&nbsp; </FONT></TD>
<TD><FONT face="Courier New" size=2>10uuzzzz&nbsp;&nbsp;&nbsp; </FONT></TD>
<TD><FONT face="Courier New" size=2>10yyyyyy&nbsp;&nbsp;&nbsp; </FONT></TD>
<TD><FONT face="Courier New" size=2>10xxxxxx&nbsp;&nbsp;&nbsp; </FONT></TD></TR></TABLE></P>
<P><FONT face=Tahoma>She could do a tiny little bit of "bit nibbling" on the very first byte as&nbsp;a way to quickly know exactly how many bytes the first code point would need.</FONT></P>
<P><FONT face=Tahoma>Now while I do consider both of these methods to qualify as both smart and clever as far as solutions go, this second method obviously has many advantages over the first in that you do not need to look at as much of the string -- you do not have to walk past the first byte. And no guessing games are needed with the return value of the function call, in fact you get to skip the function call entirely. Obviously a much cleaner solution, all the way around.</FONT></P>
<P><FONT face=Tahoma>In fact, it is fun to think about the quickest code you would write to do that nibble, with the fewest number of assembly operations once the code was compiled. Anyone want to take a stab at this last part of how to make the faster solution as speedy as possible? :-)</FONT></P>
<P>&nbsp;</P>
<P><FONT face=Tahoma><FONT color=#ff0000><EM>This post is sponsored by </EM>"ï»¿"<EM>&nbsp;</EM></FONT></FONT><EM><FONT face=Tahoma color=#ff0000><A href="http://www.fileformat.info/info/unicode/char/feff/index.htm">U+feff</A></FONT></EM><EM><FONT face=Tahoma color=#ff0000>&nbsp;(ZERO WIDTH NO-BREAK SPACE, a.k.a. the BOM, of course!)</FONT></EM></P></LI>
<hr/><p><a id="420728" href="#420728">#</a> <strong>CornedBee</strong> on 21 May 2005 6:55 AM:</p><div style="margin-left: 1em">To make it return 1, you could add:<br><br>bgt done<br>bis $0 1 $0<br>done:</div>
<p><a id="420726" href="#420726">#</a> <strong>CornedBee</strong> on 21 May 2005 6:56 AM:</p><div style="margin-left: 1em">On an Alpha processor (or a M68k if I remember correctly), I could use the bitcount instructions. Assuming $16 (that's the first function argument) contains the starting address of the string:<br><br>// Load first byte into temporary<br>ldb $1 0($16)<br>// Shift to left end of register<br>sll $1 56 $1<br>// Flip bits<br>not $1 $1<br>// Count leading zeros<br>ctlz $0 $1<br>ret<br><br>This is not perfect, because it returns 0 if the code point is 1 byte long. But it's fast.</div>
<p><a id="420733" href="#420733">#</a> <strong>rey</strong> on 21 May 2005 8:08 AM:</p><div style="margin-left: 1em">But with a lookup table you could be fast and portable, and it won't break if you encounter an invalid character. Though I admit it's pretty boring :)<br><br>const int utf8_length_tab[] = [<br>    1, 1, 1, 1, 1, 1, 1, 1,<br>    1, 1, 1, 1, 1, 1, 1, 1,<br>    0, 0, 0, 0, 0, 0, 0, 0,<br>    2, 2, 2, 2, 3, 3, 4, 0 ];<br><br>return utf8_length_tab[*(unsigned char *)utf8_str &gt;&gt; 3];</div>
<p><a id="420741" href="#420741">#</a> <strong>Mike Dimmick</strong> on 21 May 2005 9:28 AM:</p><div style="margin-left: 1em">I can't beat bit-counting instructions on a processor that supports it, but let's assume that we also want portability! Another criterion is of course readability. CornedBee also doesn't cover the case where we start on a trail byte - you're only incrementing by 1 rather than finding the beginning of the next code point. Nor do you check for the null terminator.<br><br>If we're just considering the first nibble (were you hinting at this, Michael?) there are only 16 possibilities, much of which can be done in a lookup table or a switch statement.<br><br>My first cut did a switch on ( psz[0] &amp; 0xF0 ), but the compiler didn't optimise that too well - 163 bytes, 74 instructions. My second try instead used ( psz[0] &gt;&gt; 4 ) which it actually did a rather better job of - 91 bytes, 40 instructions. These used a simple unrolled loop to find the next lead byte/single byte if we start on a trail byte.<br><br>I thought I'd try a different tactic - a table lookup. This came out even better at 63 bytes, 26 instructions, so I'm including it here:<br><br>const char* MoveToNextUTF8_3( const char* psz )<br>{<br>   static const ptrdiff_t nextOffset[] = <br>   {<br>      /* 0000 */ 1,<br>      /* 0001 */ 1,<br>      /* 0010 */ 1,<br>      /* 0011 */ 1,<br>      /* 0100 */ 1,<br>      /* 0101 */ 1,<br>      /* 0110 */ 1,<br>      /* 0111 */ 1,<br>      /* 1000 */ -1,<br>      /* 1001 */ -1,<br>      /* 1010 */ -1,<br>      /* 1011 */ -1,<br>      /* 1100 */ 2,<br>      /* 1101 */ 2,<br>      /* 1110 */ 3,<br>      /* 1111 */ 4,<br>   };<br><br>   // Special case - if NULL return same position<br>   if ( *psz == '\0' )<br>      return psz;<br><br>   ptrdiff_t offset = nextOffset[ psz[0] &gt;&gt; 4 ];<br><br>   if ( offset &lt; 0 )<br>   {<br>      if ( ( psz[1] &amp; 0xC0 ) != 0x80 )<br>         return psz + 1;<br>      if ( ( psz[2] &amp; 0xC0 ) != 0x80 )<br>         return psz + 2;<br><br>      //if ( ( psz[3] &amp; 0xC0 ) != 0x80 )<br>      return psz + 3;      <br>   }<br>   else<br>   {<br>      return psz + offset;<br>   }<br>}<br><br>Compiled with VS.NET 2003, /Oxs, extracted using dumpbin:<br><br> mov   ecx,dword ptr [esp+4]<br> mov   al,byte ptr [ecx]<br> test  al,al<br> jne   0000010B<br> mov   eax,ecx<br> ret<br>0000010B:<br> movsx eax,al<br> sar   eax,4<br> mov   eax,dword ptr [eax*4]<br> test  eax,eax<br> jge   0000013A<br> lea   eax,[ecx+1]<br> mov   dl,byte ptr [eax]<br> and   dl,0C0h<br> cmp   dl,80h<br> jne   0000013C<br> lea   eax,[ecx+2]<br> mov   dl,byte ptr [eax]<br> and   dl,0C0h<br> cmp   dl,80h<br> jne   0000013C<br> lea   eax,[ecx+3]<br> ret<br>0000013A:<br> add   eax,ecx<br>0000013C:<br> ret<br><br>It would probably be smaller if I hadn't unrolled the loop. Yep, goes down to 42 bytes, 18 instructions, and incidentally copes a little better with malformed UTF-8 (i.e. where too many trail bytes follow a lead byte). The change:<br><br>   if ( offset &lt; 0 )<br>   {<br>      do<br>      {<br>         ++psz;<br>      } <br>      while ( ( psz[0] &amp; 0xC0 ) == 0x80 );<br><br>      return psz;<br>   }<br><br>A shifting solution uses 26 instructions and 52 bytes and will cope with lead bytes that have more than 4 bits set. I made a number of errors while writing it, though... Final code:<br><br>const char* MoveToNextUTF8_5( const char* psz )<br>{<br>   // Special case - if NULL return same position<br>   if ( *psz == '\0' )<br>      return psz;<br><br>   if ( ( psz[0] &amp; 0xC0 ) == 0x80 )<br>   {<br>      ++psz;<br><br>      while ( ( psz[0] &amp; 0xC0 ) == 0x80 )<br>      {<br>         ++psz;<br>      }<br><br>      return psz;<br>   }<br><br>   // while top bit is 1, increment offset<br><br>   if ( ( psz[0] &amp; 0x80 ) == 0 )<br>      return psz + 1;<br><br>   ptrdiff_t offset = 0;<br>   char ch = psz[0];<br><br>   while ( ( ch &amp; 0x80 ) == 0x80 )<br>   {<br>      ++offset;<br>      ch &lt;&lt;= 1;<br>   }<br><br>   return psz + offset;<br>}</div>
<p><a id="420742" href="#420742">#</a> <strong>Mike Dimmick</strong> on 21 May 2005 9:34 AM:</p><div style="margin-left: 1em">After reading rey's solution (which has the same problems as CornedBee's, ahem, and won't work because you're only shifting by three when you need four, you'll go off the end of your table) I realised that I didn't need to use -1 for the 10xx cases, I could use 0, then the == operator in the test rather than &lt;. It makes no difference, it simply changes one instruction from jge to jne.</div>
<p><a id="420744" href="#420744">#</a> <strong>Michael S. Kaplan</strong> on 21 May 2005 9:53 AM:</p><div style="margin-left: 1em">Mike is definitely on the track that my 'thought experiment' was on here, though he was able to get further than I did since was doing the actual compiles. <br><br>So far its looking like he's aced this 'interview' :-)</div>
<p><a id="420811" href="#420811">#</a> <strong>ronab49</strong> on 21 May 2005 9:44 PM:</p><div style="margin-left: 1em">Here is my modification to Mike's code. It basically rearranges the test cases to make sure the cases that happen most of the time, use less CPU cycles than the cases than do not happen often. Moreover, I believe \0 is a valid one-octet codepoint Unicode, so I took out Mike's first line.<br><br>const char* MoveToNextUTF8(const char * psz ) {<br>	const char * opsz = psz;<br>	++psz; // at least one octet<br>	if (*opsz &amp; 0x80) {<br>		++psz; // at least two octets<br>		if (*opsz &amp; 0x40) {<br>			if (*opsz &amp; 0x20) {<br>				++psz; // at least three octets<br>				if (*opsz &amp; 0x10) {<br>					++psz; //  four octets<br>				}<br>				// only top 3 msb's are 1, three octets<br>			}<br>			 // only top 2 msb's are 1, two octets<br>		}<br>		else { // only top 1 msb's is 1, scan for the next valid start<br>			while ((*(++opsz) &amp; 0xc0) == 0x80);<br>			return opsz;<br>		}<br>	}<br>	return psz; // msb is 0, one octet<br>}<br><br>Here is the listing generated by VC++ 2005<br><br>  00000	8b 54 24 04	 mov	 edx, DWORD PTR _psz$[esp-4]<br>  00004	8b c2		 mov	 eax, edx<br>; Line 9<br>  00006	8a 08		 mov	 cl, BYTE PTR [eax]<br>  00008	42		 inc	 edx<br>  00009	84 c9		 test	 cl, cl<br>  0000b	79 12		 jns	 SHORT $LN3@MoveToNext<br>; Line 10<br>  0000d	42		 inc	 edx<br>; Line 11<br>  0000e	f6 c1 40	 test	 cl, 64			; 00000040H<br>  00011	74 0f		 je	 SHORT $LL2@MoveToNext<br>; Line 12<br>  00013	f6 c1 20	 test	 cl, 32			; 00000020H<br>  00016	74 07		 je	 SHORT $LN3@MoveToNext<br>; Line 13<br>  00018	42		 inc	 edx<br>; Line 14<br>  00019	f6 c1 10	 test	 cl, 16			; 00000010H<br>  0001c	74 01		 je	 SHORT $LN3@MoveToNext<br>; Line 15<br>  0001e	42		 inc	 edx<br>$LN3@MoveToNext:<br>; Line 26<br>  0001f	8b c2		 mov	 eax, edx<br>; Line 27<br>  00021	c3		 ret	 0<br>$LL2@MoveToNext:<br>; Line 22<br>  00022	40		 inc	 eax<br>  00023	8a 08		 mov	 cl, BYTE PTR [eax]<br>  00025	80 e1 c0	 and	 cl, 192			; 000000c0H<br>  00028	80 f9 80	 cmp	 cl, 128			; 00000080H<br>  0002b	74 f5		 je	 SHORT $LL2@MoveToNext<br>; Line 27<br>  0002d	c3		 ret	 0</div>
<p><a id="421015" href="#421015">#</a> <strong>Mike Dimmick</strong> on 23 May 2005 8:12 AM:</p><div style="margin-left: 1em">Ron, you can't omit the test for the null terminator! If you do this you run off the end of the string. Yes, 0 is a valid UTF-8 value, but it decodes to U+0000, the null terminator.<br><br>I wasn't sure what the termination condition should be, but CharNext returns the current position if the current position is pointing to the null terminator. For consistency we'll go with that.<br><br>I miscounted - my table-based solution, with the loop to find the next character, only uses 17 instructions. It's 18 lines in the disassembly because one of the instructions wraps in dumpbin's output. There's a slight trade-off as the table will by default be on a different page (in the read-only data segment) to the code, so when the code is 'cold' it might take slightly longer for the first operation if the data needs to be paged in as well as the code. You can probably get around this using #pragma const_seg.<br><br>Just reading the disassembly again I've noticed that I have a bug! The default 'char' for the Microsoft compiler is *signed*, and is sign-extended to 32-bits before the shift (as char is promoted to int for arithmetic operations). Hence the offset ends up being *negative* if the top bit is set (i.e. for anything interesting, code units 128 - 255). To fix, cast to unsigned char before shifting, as rey did.<br><br>That'll teach me to post before testing properly.</div>
<p><a id="421069" href="#421069">#</a> <strong>Anthony J. Mills</strong> on 23 May 2005 12:03 PM:</p><div style="margin-left: 1em">Quickest is not always the fewest number of operations, but it helps these days.<br><br>char* MoveToNextUTF8(char* psz)<br>{<br>  if (*psz != '\0') while (*(++psz) &amp; 0xC0 == 0x80) ;<br>  return psz;<br>}<br><br>I mean, make it a __fastcall (I think) where the input/output are in EAX and you get:<br><br>push edx<br>mov dl, [eax]<br>jz @Exit<br>@Loop:<br>inc eax<br>mov dl, [eax]<br>and dl, 0C0h<br>cmp dl, 080h<br>je @Loop<br>@Exit:<br>pop edx<br>ret<br><br>10 instructions. Copes very very well with malformed UTF-8. Without ample justification I wouldn't make this code any longer or harder to read than this.</div>
<p><strong>Christopher Yeleigton</strong> on 24 May 2009 2:49 PM:</p><div style="margin-left: 1em"><p>All in all, the answer is that Windows API does not support this use case and you have to roll your own. &nbsp;Pathetic.</p></div>
<p><strong>Michael S. Kaplan</strong> on 25 May 2009 10:54 PM:</p><div style="margin-left: 1em"><p>????</p>
<p>The Windows API, which is not UTF-8 based, does not have UTF-8 helper functions, and that is what you find pathetic? Okay, if you say so. I assume you design your operating systems with as many superfluous functions as possible?</p>
</div>
<p><strong>Yuhong Bao</strong> on 11 Feb 2010 8:33 PM:</p><div style="margin-left: 1em"><p>&quot;Assuming $16 (that's the first function argument) contains the starting address of the string: &quot;</p>
<p>While it didn't exist in 2005, recent AMD processors has the LZCNT instruction which would be perfect for this. Unfortunately, there is no 8-bit operand version, which means you have to shift.</p>
</div>
<hr/><p><em>referenced by</em></p><div style="margin-left: 1em"><p>2010/11/24 <a href="http://archives.miloush.net/michkap/archive/2010/11/24/10095816.html">UTF-8 on a platform whose support is overwhelmingly, almost oppressively, UTF-16</a></p><p>2007/10/23 <a href="http://archives.miloush.net/michkap/archive/2007/10/23/5617352.html">If working above U+FFFF is a problem n your program, then so is the basic stuff, too</a></p><p>2006/12/10 <a href="http://archives.miloush.net/michkap/archive/2006/12/10/1252776.html">Don't want to convert all at once? Well, maybe you could just nibble?</a></p><p>2005/05/22 <a href="http://archives.miloush.net/michkap/archive/2005/05/22/420822.html">You may want to rethink your choice of UTF, #2 (Speed of operations)</a></p></div><p><em>go to <a id="newer" href="http://archives.miloush.net/michkap/archive/2005/05/21/420762.html" title="Not every function is documented">newer</a> or <a id="older" href="http://archives.miloush.net/michkap/archive/2005/05/21/420666.html" title="Every character has a story #10: U+0478/U+0479 (CYRILLIC LETTER UK)">older</a> post, or back to <a href="http://archives.miloush.net/michkap/archive/index.html">index</a> or <a href="http://archives.miloush.net/michkap/archive/index.html#2005-05">month</a> or <a href="http://archives.miloush.net/michkap/archive/index.html#2005-05-21">day</a></em></p></body>
<!-- Mirrored from archives.miloush.net/michkap/archive/2005/05/21/420708.html by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 25 May 2017 00:42:41 GMT -->
</html>